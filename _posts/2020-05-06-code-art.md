---
title: 'Code Art'
date: 2020-05-06
permalink: /posts/2020/05/05/code-art
categories:
  - computer science
tags:
  - computer science
  - code art
---

A fun hobby of mine is trying to create art with code. I'm quite poor at the standard approach to art, so I'm quite fond of using what I know to create aesthetically pleasing things. I particularly appreciate techniques, which expose structure unexpectedly. One particular method I enjoy is writing point-wise functions for color channels, i.e. writing functions for Red, Green, and Blue, which each take pixel coordinates and return the channel value for that pixel. With this method one can translate a seemingly point-wise generation method into beautiful structures unlike their generation.

I made [this website here](https://web.eecs.utk.edu/~dnicho22/CodeArt), which allows custom code art generation in your browser. It's what I use to generate all the below samples. Check out the _Presets_ selection to see some already made art.

The easiest and most simple example is a color gradient. We can linearly interpolate each color channel from edge to edge. For instance,

```javascript
red(i, j, width, height) {
  return 255 * (height - i)/height;
}
green(i, j, width, height) {
  return 255 * (width - j)/width;
}
blue(i, j, width, height) {
  return 255 * j/width;
}
```

This gives use the nice color gradient shown below.

![Image Not Available]({{ base_path }}/images/rainbow.png)



While seemingly complex, the [Mandelbrot Set](https://en.wikipedia.org/wiki/Mandelbrot_set) maps quite nicely to this process. The Mandelbrot Set is centered around a complex series $$ z_{n+1} = z_n^2 + c $$, where $$ z,c \in \mathbb{C} $$. Given a complex number $$ c $$ and $$ z_0 = 0 $$, if $$ z_n $$ remains bounded as $$ n $$ tends towards infinity, then $$ c $$ is in the Mandelbrot Set. If $$ z_n $$ diverges towards infinity, then $$ c $$ is not in the Mandelbrot Set.

Since complex numbers are coordinates in a 2D plane, this maps exceedingly well to our pixel generation method. For any given pixel $$ (row, column) $$, if $$ c = row + i\cdot column $$ remains bounded, then draw black. Otherwise draw white at that pixel. This gives a nice rendering of the Mandelbrot Set. We can also use the number of iterations it took to diverge to determine how to shade the pixel color.

```javascript
red(i, j, width, height) {
  let x0 = (j / width) * 3 - 2;
  let y0 = ((height-i) / height) * 2.0 - 1.0;
  let x = 0, y = 0, iter = 0, max_iter = 100;

  while (x*x + y*y <= 4 && iter < max_iter) {
    let tmp = x*x - y*y + x0;
    y = 2*x*y + y0;
    x = tmp;
    iter += 1;
  }

  let scaled_color = Math.pow((iter / max_iter), 0.25) * 255;
  return scaled_color;
}
green(i, j, width, height) {
  let x0 = (j / width) * 3 - 2;
  let y0 = ((height-i) / height) * 2.0 - 1.0;
  let x = 0, y = 0, iter = 0, max_iter = 100;

  while (x*x + y*y <= 4 && iter < max_iter) {
    let tmp = x*x - y*y + x0;
    y = 2*x*y + y0;
    x = tmp;
    iter += 1;
  }

  let scaled_color = Math.pow((iter / max_iter), 0.25) * 255;
  return scaled_color;
}
blue(i, j, width, height) {
  return 255;
}
```

This code gives us the following rendering:

![Image Not Available]({{ base_path }}/images/simple_blue_mandelbrot.png)

However, we can use Hue, Saturation, Value (HSV) color channels to color the image for more color.

![Image Not Available]({{ base_path }}/images/hsv_mandelbrot.png)

We can also zoom on different sections of the set to get pretty renderings (inspired by [this post](https://codegolf.stackexchange.com/a/35739/56964)).

![Image Not Available]({{ base_path }}/images/blue_mandelbrot.png)


Likewise, any curve can be mapped into this pixel space. Take for instance, $$ r(\theta) = 2 - 2\sin\theta + \sin\theta \frac{\sqrt{\lvert \cos\theta \rvert}}{\sin\theta + 1.4} $$. 

To plot this we need to first map our i,j from pixel-space to coordinate space. This can be done by $$ x = (j / width) * (max - min) + min $$ and $$ y = ((height - i)/height) * (max - min) + min $$. Now we have an $$ x $$ and $$ y $$ and we know that $$ r = \sqrt{x^2 + y^2} $$, $$ \sin\theta = \frac{y}{r} $$, and $$ \cos\theta = \frac{x}{r} $$. After calculating $$ (r, \sin\theta, \cos\theta) $$ for a pixel $$ (i, j) $$ you can determine the color of that pixel based on the result of $$ r < 2 - 2\sin\theta + \sin\theta \frac{\sqrt{\lvert \cos\theta \rvert}}{\sin\theta + 1.4} $$. If true, then color the pixel, otherwise don't.

This is fairly straightforward to translate to code and it gives us a nice big heart:

![Image Not Available]({{ base_path }}/images/big_heart.png)

You can make this a pattern by offsetting $$ x $$ and $$ y $$ by $$ round(x/8)*8 $$ and $$ round(y/8)*8 $$, respectively. This gives a nice grid pattern.

![Image Not Available]({{ base_path }}/images/grid_heart.png)